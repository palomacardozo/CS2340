{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>Atlanta Food Finder</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDtUL74Sdloq7RMtzi7Qvcgzstf79Cnons&libraries=places"></script>
    <link rel="stylesheet" href="{% static 'main.css' %}">
    <style>
        img {
            width: 100%;
            height: auto;
            max-width: 100%;
        }
        .content {
            text-align: center;
        }
        #map {
            margin: 0 auto;
            border: 2px solid #fff;
            height: 490px;
            width: 100%;
        }
        #search-box {
            padding: 10px;
            width: 80%;
            max-width: 500px;
            margin: 10px auto;
            display: block;
        }
        .place-details-card, .reviews-card {
            background-color: white;
            padding: 20px;
            margin: 10px; /* Margin around the cards */
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            flex: 1; /* Ensure both cards take equal space */
            display: flex;
            flex-direction: column; /* Make sure content stacks vertically */
            height: 400px;
            font-size: 16px; /* Base font size for readability */
        }

        .place-details-card h3 {
            font-size: 1.8em; /* Larger font size for headings */
            margin-bottom: 10px; /* Space below headings */
        }

        .place-details-card .stars {
            color: gold; /* Color for the stars */
            font-size: 1.2em; /* Adjust size if necessary */
        }


        .reviews-card h4 {
            font-size: 1.5em; /* Slightly smaller for subheadings */
            margin-bottom: 10px; /* Space below subheadings */
        }

        .reviews-card {
            overflow-y: auto; /* Enable vertical scrolling */
        }

        .review {
            margin-bottom: 15px; /* Space between reviews */
            font-size: 14px; /* Font size for reviews */
        }

        .review strong {
            color: #333; /* Dark color for the reviewer name */
        }

        .review p {
            color: #555; /* Slightly lighter for review text */
        }

        .review .stars {
            color: gold; /* Color for the stars */
            font-size: 1.2em; /* Adjust size if necessary */
        }

        .place-details-container {
            display: flex; /* Align cards horizontally */
            justify-content: space-between; /* Space between cards */
            max-width: 1200px; /* Optional: limit the overall width */
            margin: 20px auto; /* Center the container */
            height: 400px; /* Set a fixed height for the container */
        }

        #location-search {
            margin-bottom: 10px;
        }

    </style>

</head>
<body>

{% for restaurant in places %}
    <p>Restaurant: {{ restaurant.name }} - Place ID: {{ restaurant.place_id }}</p> <!-- Log place_id -->
    <button class="heart-button" data-place-id="{{ restaurant.place_id }}" id="{{ restaurant.place_id }}">
        ü§ç Add to Favorites
    </button>
{% endfor %}

<div class="header-image">
    <div class="navbar">
        <a href="{% url 'home' %}">Home</a>
        <a href="{% url 'favorites' %}">Favorites</a>
        {% if user.is_authenticated %}
        <form method="post" action="{% url 'logout' %}">
            {% csrf_token %}
            <button type="submit" class="nav-link logout-button">Logout</button>
        </form>
        {% else %}
        <a href="{% url 'login' %}">Login</a>
        <a href="{% url 'signup' %}">Signup</a>
        {% endif %}
    </div>
    <h1>Atlanta Food Finder</h1>
    <h2>Explore restaurants near you</h2>
</div>

<div class="search-area">
    <input id="search-box" type="text" placeholder="Search for restaurant or a cuisine">
    <input id="location-search" type="text" placeholder="Enter a location">
    <button id="location-submit">Search</button>
</div>
<div class="filter-container">
    <div class="filter-area">
         <label for="radius">Select search radius:</label>
        <select id="radius">
            <option value="500">0.5 km</option>
            <option value="750">0.75 km</option>
            <option value="1000" selected>1 km</option>
            <option value="2000">2 km</option>
            <option value="3000">3 km</option>
            <option value="4000">4 km</option>
            <option value="5000">5 km</option>
        </select>
        <button id="set-radius">Set Radius</button>
        <label for="min-rating">Select minimum rating:</label>
        <select id="min-rating">
            <option value="0">All ratings</option>
            <option value="1">1 star</option>
            <option value="2">2 stars</option>
            <option value="3">3 stars</option>
            <option value="4">4 stars</option>
            <option value="5">5 stars</option>
        </select>
        <button id="set-rating">Set Minimum Rating</button>
    </div>
</div>
    <div id="map"></div>
    <div id="place-details"></div>

    <script>
        var map, service, infowindow;
        var searchRadius = 1000; // Default radius in meters
        var markers = [];  // Array to hold all markers
        var minRating = 0;
        var userLocation = {lat: 33.7488, lng: -84.3879};
        var cuisineSearch = false;

        google.maps.event.addDomListener(window, 'load', initMap);


        function initMap() {
            console.log("Initializing map..."); // Log message to check if function is called
            var defaultLocation = {lat: -34.397, lng: 150.644};
            map = new google.maps.Map(document.getElementById('map'), {
                center: defaultLocation,
                zoom: 8
            });

            infowindow = new google.maps.InfoWindow();

            //Initialize geolocation
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    userLocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    map.setCenter(userLocation);
                    map.setZoom(15);
                    new google.maps.Marker({
                        map: map,
                        position: userLocation,
                        title: "Your location",
                        icon: {
                         url: "http://maps.google.com/mapfiles/ms/icons/blue-dot.png" // Use a blue marker icon
                         }
                    });
                    searchNearbyRestaurants(userLocation);
                }, function() {
                    console.error("Geolocation permission denied or unavailable.");
                    searchNearbyRestaurants(defaultLocation);
                });
            } else {
                console.error("Geolocation is not supported by this browser.");
                searchNearbyRestaurants(defaultLocation);
            }

            // Search for places using the search box
            var input = document.getElementById('search-box');
            var searchBox = new google.maps.places.SearchBox(input);
            map.addListener('bounds_changed', function() {
                searchBox.setBounds(map.getBounds());
            });

            searchBox.addListener('places_changed', function() {
                clearMarkers();
                var places = searchBox.getPlaces();
                if (places.length === 0) {
                    return;
                }
                var bounds = new google.maps.LatLngBounds();
                places.forEach(function(place) {
                    cuisineSearch = true;
                        if (place.geometry && place.rating >= minRating) {
                            const placeLocation = {
                                lat: place.geometry.location.lat(), // Assuming place is a valid Google Maps place object
                                lng: place.geometry.location.lng()
                            };
                            const distance = haversineDistance(userLocation, placeLocation) * 1000;
                            console.log("Haversine Distance: " + distance);
                            console.log("searchRadius = " + searchRadius);
                            console.log("place name = " + place.name)
                            if (distance < searchRadius) {
                                console.log("creatingMarker");
                                createMarker(place, map);
                                bounds.extend(place.geometry.location);
                            }
                        }
                });
                map.fitBounds(bounds);
            });

            // Click event listener for the map
            map.addListener('click', function(event) {
                searchPlaceDetails(event.latLng);
            });

            // Event listener for location search
            document.getElementById('location-submit').addEventListener('click', function() {
                var location = document.getElementById('location-search').value;
                if (location) {
                    clearMarkers();
                    var geocoder = new google.maps.Geocoder();
                    geocoder.geocode({'address': location}, function(results, status) {
                        if (status === google.maps.GeocoderStatus.OK) {
                            userLocation = results[0].geometry.location;
                            map.setCenter(userLocation);
                            searchNearbyRestaurants(userLocation);
                        } else {
                            alert('Location not found: ' + status);
                        }
                    });
                }
            });

            document.getElementById('set-rating').addEventListener('click', function() {
                minRating = parseFloat(document.getElementById('min-rating').value);
                clearMarkers();
                if (cuisineSearch) {
                    var places = searchBox.getPlaces();
                    if (places.length === 0) {
                        return;
                    }
                    var bounds = new google.maps.LatLngBounds();
                    places.forEach(function(place) {
                        cuisineSearch = true;
                        if (place.geometry && place.rating >= minRating) {
                            const placeLocation = {
                                lat: place.geometry.location.lat(), // Assuming place is a valid Google Maps place object
                                lng: place.geometry.location.lng()
                            };
                            const distance = haversineDistance(userLocation, placeLocation) * 1000;
                            console.log("Haversine Distance: " + distance);
                            console.log("searchRadius = " + searchRadius);
                            console.log("place name = " + place.name)
                            if (distance < searchRadius) {
                                console.log("creatingMarker");
                                createMarker(place, map);
                                bounds.extend(place.geometry.location);
                            }
                        }
                    });
                    map.fitBounds(bounds);
                } else {
                    searchNearbyRestaurants(userLocation); // Re-fetch restaurants with the new minimum rating
                }
            });


            // Event listener for setting radius
            document.getElementById('set-radius').addEventListener('click', function() {
                searchRadius = parseInt(document.getElementById('radius').value);
                //var userLocation = { lat: map.getCenter().lat(), lng: map.getCenter().lng() };
                clearMarkers();
                if (cuisineSearch) {
                    var places = searchBox.getPlaces();
                    if (places.length === 0) {
                        return;
                    }
                    var bounds = new google.maps.LatLngBounds();
                    places.forEach(function(place) {
                        cuisineSearch = true;
                        if (place.geometry && place.rating >= minRating) {
                            const placeLocation = {
                                lat: place.geometry.location.lat(), // Assuming place is a valid Google Maps place object
                                lng: place.geometry.location.lng()
                            };
                            const distance = haversineDistance(userLocation, placeLocation) * 1000;
                            console.log("Haversine Distance: " + distance);
                            console.log("searchRadius = " + searchRadius);
                            console.log("place name = " + place.name)
                            if (distance < searchRadius) {
                                console.log("creatingMarker");
                                createMarker(place, map);
                                bounds.extend(place.geometry.location);
                            }
                        }
                    });
                    map.fitBounds(bounds);
                } else {
                    searchNearbyRestaurants(userLocation); // Re-fetch restaurants
                }
            });
        }

        function searchNearbyRestaurants(location) {
            clearMarkers();
            cuisineSearch = false;
            var request = {
                location: location,
                radius: searchRadius,  // Use the updated radius
                type: ['restaurant']
            };
            service = new google.maps.places.PlacesService(map);
            var cuisineService = "asf";
            service.nearbySearch(request, function(results, status) {
                if (status === google.maps.places.PlacesServiceStatus.OK) {
                    // Clear previous markers if needed (optional)
                    clearMarkers();

                    results.forEach(function(place) {
                        if (place.rating >= minRating) {
                            createMarker(place, map); // Create markers for each place
                        }
                    });
                } else {
                    console.error('Places API request failed: ' + status);
                }
            });
        }
        function clearMarkers() {
            // Clear existing markers from the map
            markers.forEach(function(marker) {
                marker.setMap(null); // Remove marker from the map
            });
            markers = []; // Reset the markers array
        }

        function searchPlaceDetails(location) {
            var detailsDiv = document.getElementById('place-details');
            detailsDiv.innerHTML = '';  // Clear previous details

            var request = {
                location: location,
                radius: '50',  // Search within 50 meters
                type: ['restaurant']
            };

            service.nearbySearch(request, function(results, status) {
                if (status === google.maps.places.PlacesServiceStatus.OK && results.length > 0) {
                    var placeId = results[0].place_id; // Get the first restaurant
                    getPlaceDetails(placeId);
                } else {
                    infowindow.setContent("No restaurant found at this location.");
                    infowindow.setPosition(location);
                    infowindow.open(map);
                }
            });
        }

        function displayRestaurants(restaurants, map) {
            // Iterate through the list of restaurants (places)
            restaurants.forEach(place => {
        // Create a marker for each restaurant
            createMarker(place, map);
            });
        }

        function getPlace(placeId) {
            return new Promise((resolve, reject) => {
                var request = {
                    placeId: placeId,
                    fields: ['name', 'rating', 'formatted_phone_number', 'geometry', 'website', 'vicinity', 'formatted_address', 'types', 'reviews']
                };

                service.getDetails(request, function(place, status) {
                    if (status === google.maps.places.PlacesServiceStatus.OK) {
                        place.place_id = placeId;
                        resolve(place); // Resolve the promise with the place
                    } else {
                        console.error('Place details request failed: ' + status);
                        reject(status); // Reject the promise with the error status
                    }
                });
            });
        }
        // Function to check if any keywords from the set are in the array
        function containsKeywords(arr, keywordSet) {
            let count = 0;
            console.log(keywordSet);
            for (const word of arr) {
                if (keywordSet.has(word)) {
                    console.log(word);
                    count++;
                }
            }
            console.log(count);
            return count;
        }

        function getPlaceDetails(placeId) {
            var request = {
                placeId: placeId,
                fields: ['name', 'rating', 'formatted_phone_number', 'geometry', 'website', 'vicinity', 'formatted_address', 'types', 'reviews']
            };

            service.getDetails(request, function(place, status) {
                if (status === google.maps.places.PlacesServiceStatus.OK) {
                    place.place_id = placeId;
                    displayPlaceDetails(place);
                    // Create a link to open the restaurant's location in Google Maps
                    const googleMapsLink = `https://www.google.com/maps/place/?q=place_id:${place.place_id}`;

                    // Set the content of the InfoWindow
                    infowindow.setContent(`
                        <div>
                            <strong>${place.name}</strong><br>
                            <a href="${googleMapsLink}" target="_blank">View on Google Maps</a>
                        </div>
                    `);
                    infowindow.setPosition(place.geometry.location);
                    infowindow.open(map);
                } else {
                    console.error('Place details request failed: ' + status);
                }
            });
        }

        function displayPlaceDetails(place) {
            var detailsDiv = document.getElementById('place-details');
            detailsDiv.innerHTML = '';  // Clear previous details
            // Example usage
            /*
            var reviewed = service.getDetails({ placeId: placeId, fields: ['name', 'rating', 'reviews'] }, (place, status) => {
                if (status === google.maps.places.PlacesServiceStatus.OK) {
                    displayReviews(place.reviews);
                } else {
                    document.getElementById('output').innerHTML = 'Error retrieving details.';
                }
            }); */
            var review_text = "";
            if (place.reviews && place.reviews.length > 0) {
                  place.reviews.forEach((review, index) => {
                      review_text += review.text;
                  });
                }
            const arr_reviews = review_text.split(" ").map(word => word.toLowerCase());
            const italian = new Set([
            "pasta", "pizza", "pizzeria", "cucina", "trattoria", "osteria", "ristorante", "bistro", "enoteca",
            "taverna", "gusto", "sapori", "pomodoro", "mamma", "nonna", "amici", "roma", "napoli", "toscana",
            "vino", "dolce", "al forno", "fresco", "bella", "buona", "vespa", "cantina", "sole", "margherita",
            "milano", "piazza", "gnocchi", "bottega", "sapori", "vittoria", "rosso", "bianco", "verde",
            "fiorentina", "tartufo", "panini"
            ]);

            const mexican = new Set([
                "taco", "burrito", "quesadilla", "enchilada", "guacamole", "salsa", "fajita", "tortilla", "nachos",
                "chimichanga", "tamale", "chorizo", "carnitas", "carne asada", "pollo", "mole", "pozole",
                "tostada", "sopes", "elote", "flan", "horchata", "margarita", "ceviche", "pico de gallo",
                "al pastor", "tinga", "barbacoa", "tapatio", "chalupa", "menudo", "huevos rancheros",
                "refried beans", "frijoles", "arroz", "tres leches", "empanada", "churros", "taqueria",
                "sopaipilla", "agua fresca", "sangria", "tequila", "mezcal", "chipotle", "poblano",
                "chile relleno", "jalape√±o", "habanero", "serrano", "carnitas", "birria", "pico",
                "sopa", "ranchero", "adobo", "tinga", "verde", "salsa verde", "salsa roja", "chimichurri",
                "nopal", "mexicana", "cochinita pibil", "pico de gallo", "tajin", "flautas", "tostadas",
                "queso", "queso fresco", "crema", "street corn", "baja", "molcajete", "tamales",
                "campechano", "aguachile", "chapulines", "puerco", "cilantro", "lime", "tacos al carbon"
            ]);

            const chinese = new Set([
                "dim sum", "wok", "dragon", "lotus", "jade", "peking", "szechuan", "canton", "mandarin",
                "hunan", "shanghai", "bamboo", "phoenix", "golden", "panda", "garden", "palace", "dynasty",
                "emperor", "lucky", "fortune", "noodle", "dumpling", "tea house", "sichuan", "chopsticks",
                "great wall", "lantern", "china", "beijing", "ming", "yuan", "tiger", "zen", "pearl",
                "oriental", "pagoda", "rice", "hot pot", "wonton", "kung pao", "soy", "sesame", "buddha",
                "chow mein", "lo mein", "fried rice"
            ]);

            const mediterranean = new Set([
                "hummus", "falafel", "pita", "shawarma", "kebab", "gyro", "tzatziki", "tabbouleh", "baba ganoush",
                "dolma", "souvlaki", "baklava", "spanakopita", "moussaka", "tahini", "feta", "olives",
                "lamb", "chicken shawarma", "bulgur", "couscous", "mezze", "halloumi", "fattoush", "za'atar",
                "harissa", "sumac", "basmati", "rice pilaf", "mint", "parsley", "grape leaves", "lebneh",
                "yogurt", "garlic sauce", "kofta", "manakish", "borek", "shakshuka", "kibbeh", "saganaki",
                "briam", "brioche", "fasolia", "freekeh", "labneh", "mujaddara", "pastitsio", "zaatar",
                "octopus", "calamari", "taramasalata", "swordfish", "olive oil", "fava beans", "kalamata olives",
                "pomegranate", "lemon", "cucumber", "tomato", "eggplant", "rose water", "sesame", "baklawa",
                "loukoumades", "orzo", "tarator", "lentil soup", "grilled vegetables", "zucchini", "capers",
                "sardines", "figs", "chickpeas", "herbs", "spices", "turkish coffee", "greek salad",
                "cumin", "cardamom", "coriander", "dukkah", "pistachio", "dates", "baba ghanoush", "saffron",
                "grilled fish", "fennel", "saffron", "sesame seeds", "rosemary", "thyme"
            ]);

            const american = new Set([
                "grill", "barbecue", "bbq", "diner", "burger", "steakhouse", "smokehouse", "roadhouse",
                "tavern", "saloon", "chophouse", "wings", "pit", "ranch", "pub", "bar", "brewhouse",
                "hot dog", "cheeseburger", "griddle", "shack", "joint", "brisket", "southern",
                "fried chicken", "ribs", "buffalo", "american", "smoke", "patty", "cheddar",
                "all-american", "route", "texas", "bacon", "chili", "fries", "skillet", "biscuits",
                "comfort food", "apple pie", "country", "barn", "depot", "wagon", "deli", "meatloaf",
                "caf√©", "pancake", "sandwich", "milkshake", "roadside", "grub", "blue plate", "brewery"
            ]);

            const fastFood = new Set([
                "burger", "fries", "pizza", "chicken", "sandwich", "sub", "taco", "wrap", "wings", "hot dog",
                "bbq", "grill", "shack", "deli", "drive-thru", "fried", "burrito", "donuts", "shake",
                "ice cream", "fast", "express", "quick", "combo", "meal", "value", "snack", "wing", "cheeseburger",
                "nuggets", "soda", "sliders", "bites", "box", "tenders", "bucket", "to go", "chick", "patty",
                "crispy", "cheddar", "double", "king", "subway", "waffle", "mc", "junior", "loaded", "drive in",
                "quick bites", "takeaway", "fresh", "deluxe", "supreme", "ultimate"
            ]);

            const korean = new Set([
                "korean bbq", "bulgogi", "kimchi", "korean", "bibimbap", "galbi", "samgyupsal", "jjigae",
                "hot pot", "tteokbokki", "kimbap", "ssam", "jajangmyeon", "dak", "sundubu", "manduu",
                "gogi", "chimaek", "banchan", "ssam", "seoul", "gangnam", "soju", "kimchi stew", "hoddeok",
                "yukgaejang", "gopchang", "jumak", "jeon", "kkakdugi", "pajeon", "budae jjigae",
                "japchae", "hanjeongsik", "tteok", "kalbi", "sundae", "makgeolli", "sikhye", "bingsu",
                "chogajib", "chimaek", "doenjang", "bossam", "naengmyeon", "baekban", "karaage"
            ]);

            const bakeryKeywords = new Set([
                "bread", "croissant", "danish", "pastry", "muffin", "cookie", "brownie",
                "cupcake", "doughnut", "tart", "biscotti", "cake", "pudding", "eclair",
                "scone", "macaron", "cheesecake", "baguette", "focaccia", "pita", "brioche",

                "fresh", "sweet", "savory", "chocolate", "vanilla", "almond", "cinnamon",
                "lemon", "cream cheese", "buttercream", "nutella", "fruit", "filling",
                "glaze", "caramel", "icing", "whipped cream", "sprinkles", "bakery", "treat"
            ]);

            const barKeywords = new Set([
                "cocktail", "beer", "whiskey", "vodka", "gin", "rum", "tequila", "brandy",
                "shots", "liquor", "mixology", "draft", "pint", "margarita", "mojito",
                "martini", "highball", "sour", "lager", "ale", "stout", "IPA", "sour",

                "happy hour", "drink", "menu", "special", "signature", "refreshing",
                "smooth", "strong", "bitter", "sweet", "spicy", "fruity", "fizzy",

                "local", "craft", "brewery", "distillery", "brewpub", "specialty",
                "house-made", "tasting"
            ]);

            var cuisineType;
            var currentResults = 0;
            cuisineType = "Restaurant";
            if (containsKeywords(arr_reviews, italian) > currentResults){
                currentResults = containsKeywords(arr_reviews, italian);
                cuisineType = "Italian Restaurant";
            }
            if (containsKeywords(arr_reviews, american) > currentResults){
                currentResults = containsKeywords(arr_reviews, american);
                cuisineType = "American Restaurant";
            }
            if (containsKeywords(arr_reviews, chinese) > currentResults){
                currentResults = containsKeywords(arr_reviews, chinese);
                cuisineType = "Chinese Restaurant";
            }
            if (containsKeywords(arr_reviews, korean) > currentResults){
                currentResults = containsKeywords(arr_reviews, korean);
                cuisineType = "Korean Restaurant";
            }
            if (containsKeywords(arr_reviews, mexican) > currentResults){
                currentResults = containsKeywords(arr_reviews, mexican);
                cuisineType = "Mexican Restaurant"
            }
            if (containsKeywords(arr_reviews, bakeryKeywords) > currentResults) {
                currentResults = containsKeywords(arr_reviews, bakeryKeywords);
                cuisineType = "Bakery"
            }
            if (containsKeywords(arr_reviews, barKeywords) > currentResults) {
                currentResults = containsKeywords(arr_reviews, barKeywords);
                cuisineType = "Bar"
            }
            if (containsKeywords(arr_reviews, mediterranean) > currentResults) {
                currentResults = containsKeywords(arr_reviews, mediterranean);
                cuisineType = "Mediterranean Restaurant"
            }
            if (containsKeywords(arr_reviews, fastFood) > currentResults){
                currentResults = containsKeywords(arr_reviews, fastFood);
                cuisineType = "Fast Food Restaurant";
            }
            const maxReviewLength = 200; // Set your character limit here
            const reviews = place.reviews ? place.reviews.map((review, index) => {
                let reviewText = review.text;
                let isLongReview = reviewText.length > maxReviewLength;
                let truncatedReview = isLongReview ? reviewText.substring(0, maxReviewLength) + '...' : reviewText;

                return `
                    <div class="review">
                        <p><strong>${review.author_name}</strong></p>
                        <p>Rating: ${generateStars(review.rating)} (${review.rating || 'N/A'} / 5 stars)</p>
                        <p class="review-text">${truncatedReview}</p>
                        ${isLongReview ? `<a href="#" class="see-more" data-index="${index}">See more</a>` : ''}
                    </div>
                    <div class="full-review" id="full-review-${index}" style="display: none;">
                        <p>"${reviewText}"</p>
                    </div>
                `;
            }).join('') : '<p>No reviews available</p>';

            const ratingStars = generateStars(place.rating); // Get star representation

            detailsDiv.innerHTML = `
                <div class="place-details-container">
                    <div class="place-details-card">
                        <h3>${place.name}</h3>
                        <p><strong>Rating:</strong> ${ratingStars} (${place.rating || 'N/A'})</p>
                        <p><strong>Phone:</strong> ${place.formatted_phone_number || 'N/A'}</p>
                        <p><strong>Address:</strong> ${place.formatted_address || place.vicinity || 'N/A'}</p>
                        <p><strong>Website:</strong> <a href="${place.website}" target="_blank">${place.website || 'N/A'}</a></p>
                        <p><strong>Cuisine Type:</strong> ${cuisineType}</p>
                        <div class="heart-button-container">
                            <p style="display: inline; margin-right: 10px; background: transparent"><strong>Add to Your Favorites:</strong></p>
                            <button class="heart-button" id="${place.place_id}" data-place-id="${place.place_id}">
                                ü§ç
                            </button>
                        </div>
                    </div>
                    <div class="reviews-card">
                        <h4>Reviews:</h4>
                        <div class="reviews">${reviews}</div>
                    </div>
                </div>
            `;

            // Add event listeners for "See more" links
            const seeMoreLinks = detailsDiv.getElementsByClassName('see-more');
            for (let link of seeMoreLinks) {
                link.addEventListener('click', function(event) {
                    event.preventDefault();
                    const index = this.getAttribute('data-index');
                    const fullReviewDiv = document.getElementById(`full-review-${index}`);
                    const reviewTextDiv = this.previousElementSibling; // The review text element

                    // Toggle the full review and update the text accordingly
                    if (fullReviewDiv.style.display === 'none') {
                        fullReviewDiv.style.display = 'block'; // Show full review
                        reviewTextDiv.style.display = 'none'; // Hide truncated text
                        this.textContent = 'See less'; // Change link text
                    } else {
                        fullReviewDiv.style.display = 'none'; // Hide full review
                        reviewTextDiv.style.display = 'block'; // Show truncated text
                        this.textContent = 'See more'; // Reset link text
                    }
                });
            }
        }


        // Function to generate star symbols based on the rating
        function generateStars(rating) {
            if (!rating) return ''; // Return empty if no rating
            let stars = '';
            for (let i = 0; i < 5; i++) {
                if (i < rating) {
                    stars += '‚òÖ'; // Full star
                } else {
                    stars += '‚òÜ'; // Empty star
                }
            }
            return `<span class="stars">${stars}</span>`; // Wrap stars in a span with class
        }

        function createMarker(place, map) {
            const marker = new google.maps.Marker({
                position: place.geometry.location,
                map: map,
                title: place.name
            });

            // Push the created marker into the markers array
            markers.push(marker);

            google.maps.event.addListener(marker, 'click', function () {
                getPlaceDetails(place.place_id); // Fetch details on click
            });
        }

        function toRad(value) {
            return value * Math.PI / 180;
        }

        function haversineDistance(coord1, coord2) {
            const R = 6371; // Radius of the Earth in kilometers

            const dLat = toRad(coord2.lat - coord1.lat);
            const dLng = toRad(coord2.lng - coord1.lng);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in kilometers
        }

        google.maps.event.addDomListener(window, 'load', initMap);

        // Log to verify the script is loaded
        console.log("favorites.js loaded!");

        document.addEventListener('DOMContentLoaded', function() {
            console.log("JavaScript loaded and event delegation activated!");

            document.body.addEventListener('click', function(event) {
                if (event.target.classList.contains('heart-button')) {
                    event.preventDefault();
                    console.log("Heart button clicked!");
                    console.log(event)

                    const heartButton = event.target;
                    const placeId = heartButton.getAttribute('data-place-id');
                    const isFavorited = !heartButton.classList.contains('hearted');

                    console.log('Is Favorited:', isFavorited); // Add this for debugging
                    console.log('Place ID:', placeId);
                    console.log('Hearted class added:', heartButton.classList);  // Check if the class is added

                    // Toggle the hearted class
                    heartButton.classList.toggle('hearted');

                    getPlace(placeId)
                        .then(place => {
                            place.isFavorited = isFavorited;

                            // Send AJAX request to update favorites
                            fetch(`/add_to_favorites/${placeId}/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': getCookie('csrftoken'),
                                    'X-Requested-With': 'XMLHttpRequest'
                                },
                                body: JSON.stringify({favorited: isFavorited})
                            })
                                .then(response => {
                                    if (!response.ok) {
                                        console.error('Failed to update favorites.');
                                        return;
                                    }

                                    console.log("Favorites updated successfully!");  // Log successful updates

                                    if (isFavorited) {
                                        heartButton.textContent = '‚ù§Ô∏è';
                                        console.log("Restaurant added to favorites!");
                                    } else {
                                        heartButton.textContent = 'ü§ç';
                                        console.log("Restaurant removed from favorites.");
                                    }

                                })
                                .catch(error => console.error('Error:', error));
                        })
                        .catch(error => {
                            console.error('Error:', error);
                        });


                    /*
                    // Send AJAX request to update favorites
                    fetch(`/add_to_favorites/${placeId}/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken'),
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({ favorited: isFavorited })
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error('Failed to update favorites.');
                            return;
                        } else {
                            console.log("Favorites updated successfully!");  // Log successful updates
                        }

                        if (isFavorited) {
                            heartButton.textContent = '‚ù§Ô∏è Remove from Favorites';
                        } else {
                            heartButton.textContent = 'ü§ç Add to Favorites';
                        }
                    })
                    .catch(error => console.error('Error:', error)); */
                // 'X' click for removing favorites
                } else if (event.target.classList.contains('remove-button')) {
                    event.preventDefault();

                    const placeId = event.target.getAttribute('data-place-id');
                    console.log(`Removing favorite with Place ID: ${placeId}`);

                    fetch(`/favorites/remove/${placeId}/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken'),
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({ remove: true })
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error('Failed to remove favorite.');
                            return;
                        }

                        console.log("Favorite removed successfully!");
                        event.target.closest('.place-details-card').remove(); // Remove the card from the DOM
                    })
                    .catch(error => console.error('Error:', error));
                }
            });

            // Function to get the CSRF token from cookies
            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }
        });
    </Script>

</body>
</html>